# Network Implementation Change Request

We're switching from Network.framework to MultipeerConnectivity for device communication between the iOS and macOS apps. This change is motivated by several key factors:

1. **Reliability Issues**: We were encountering TLS/SSL handshake problems and connection instability with the Network.framework implementation.
2. **Complexity**: The custom networking solution required extensive error handling and edge case management.
3. **Security**: MultipeerConnectivity provides built-in encryption and authentication.

## Required Changes

Please update the iOS app's networking layer to use MultipeerConnectivity with the following specifications:

### 1. Service Configuration
```swift
static let serviceType = "lightbox-app"  // Must match Mac app
```

### 2. Core Implementation
```swift
class NetworkService: NSObject, ObservableObject {
    // Published Properties
    @Published var connectionState: NetworkConnectionState = .disconnected
    @Published var isConnected = false
    @Published var isAuthenticated = false
    
    // Private Properties
    private var session: MCSession?
    private var serviceAdvertiser: MCNearbyServiceAdvertiser?
    private var serviceBrowser: MCNearbyServiceBrowser?
    private let peerId: MCPeerID
    
    private var discoveryInfo: [String: String] {
        return ["platform": "iOS"]
    }
}
```

### 3. Initialization
```swift
override init() {
    peerId = MCPeerID(displayName: UIDevice.current.name)
    super.init()
    setupMultipeerConnectivity()
}

private func setupMultipeerConnectivity() {
    // Create and configure session
    session = MCSession(
        peer: peerId,
        securityIdentity: nil,
        encryptionPreference: .required
    )
    session?.delegate = self
    
    // Setup advertising
    serviceAdvertiser = MCNearbyServiceAdvertiser(
        peer: peerId,
        discoveryInfo: discoveryInfo,
        serviceType: Self.serviceType
    )
    serviceAdvertiser?.delegate = self
    
    // Setup browsing
    serviceBrowser = MCNearbyServiceBrowser(
        peer: peerId,
        serviceType: Self.serviceType
    )
    serviceBrowser?.delegate = self
    
    startServices()
}
```

### 4. Required Protocol Implementations

#### MCSessionDelegate
```swift
extension NetworkService: MCSessionDelegate {
    func session(_ session: MCSession, peer peerID: MCPeerID, didChange state: MCSessionState) {
        DispatchQueue.main.async {
            switch state {
            case .connected:
                self.connectionState = .connected
                self.isConnected = true
                self.isAuthenticated = true
            case .connecting:
                self.connectionState = .connecting
            case .notConnected:
                self.connectionState = .disconnected
                self.isConnected = false
                self.isAuthenticated = false
            @unknown default:
                break
            }
        }
    }
    
    func session(_ session: MCSession, didReceive data: Data, fromPeer peerID: MCPeerID) {
        // Handle incoming data (JSON messages)
        if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
            handleReceivedMessage(json)
        }
    }
    
    // Required protocol stubs
    func session(_ session: MCSession, didReceive stream: InputStream, withName streamName: String, fromPeer peerID: MCPeerID) {}
    func session(_ session: MCSession, didStartReceivingResourceWithName resourceName: String, fromPeer peerID: MCPeerID, with progress: Progress) {}
    func session(_ session: MCSession, didFinishReceivingResourceWithName resourceName: String, fromPeer peerID: MCPeerID, at localURL: URL?, withError error: Error?) {}
}
```

#### MCNearbyServiceAdvertiserDelegate
```swift
extension NetworkService: MCNearbyServiceAdvertiserDelegate {
    func advertiser(_ advertiser: MCNearbyServiceAdvertiser, didReceiveInvitationFromPeer peerID: MCPeerID, withContext context: Data?, invitationHandler: @escaping (Bool, MCSession?) -> Void) {
        // Auto-accept connections from Mac app
        if peerID.displayName == "MacDesktop" {
            invitationHandler(true, session)
        }
    }
}
```

#### MCNearbyServiceBrowserDelegate
```swift
extension NetworkService: MCNearbyServiceBrowserDelegate {
    func browser(_ browser: MCNearbyServiceBrowser, foundPeer peerID: MCPeerID, withDiscoveryInfo info: [String: String]?) {
        // Connect to Mac app when found
        if peerID.displayName == "MacDesktop" {
            browser.invitePeer(peerID, to: session!, withContext: nil, timeout: 30)
        }
    }
    
    func browser(_ browser: MCNearbyServiceBrowser, lostPeer peerID: MCPeerID) {
        // Handle peer loss if needed
    }
}
```

### 5. Message Sending
```swift
func sendMessage(_ message: [String: Any]) {
    guard let session = session,
          !session.connectedPeers.isEmpty,
          let data = try? JSONSerialization.data(withJSONObject: message) else {
        return
    }
    
    do {
        try session.send(data, toPeers: session.connectedPeers, with: .reliable)
    } catch {
        print("Failed to send message: \(error)")
    }
}
```

## Important Notes

1. The service type "lightbox-app" must match exactly between iOS and macOS apps
2. The Mac app will identify itself with the peer name "MacDesktop"
3. All data communication should be done using JSON messages
4. The connection is automatically encrypted by MultipeerConnectivity
5. Both apps must be in the foreground for discovery to work
6. Users will need to grant permission for local network access

## Required Info.plist Entries
```xml
<key>NSLocalNetworkUsageDescription</key>
<string>LightBox needs to access your local network to discover and connect to your Mac.</string>
<key>NSBonjourServices</key>
<array>
    <string>_lightbox-app._tcp</string>
</array>
```

Please implement these changes and test the connection with the updated Mac app. The connection should be automatic when both apps are running and on the same network. 